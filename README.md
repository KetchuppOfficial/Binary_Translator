![Linux](https://img.shields.io/badge/Linux-FCC624?style=for-the-badge&logo=linux&logoColor=black)

# Binary Translator

This project is the final part of the programming and computer architecture course by [Ilya Dedinsky (aka ded32)](https://github.com/ded32).

## General Information

This program is a binary translator from bytecode generated by [my assembler](https://github.com/KetchuppOfficial/Processor) into x86-64 machine code. Execution of the machine code is implemented as a JIT-compiler. You can find information about my processor instructions and their nasm and x86-64 equivalents [here](/ISA.md) (pay special attention to **in** and **out**).

## Dependencies

Before installing **Binary_Translator** make sure you have [My_Lib](https://github.com/KetchuppOfficial/My_Lib) installed on your PC. This library is an integral part of the project. Nothing will work without it.

## Build and run

**Binary_Translator** is released for Linux only.

**Step 1:** Make empty folder.

**Step 2:** Clone Binary_Translator and My_Lib repositories to this folder:
```bash
git clone git@github.com:KetchuppOfficial/Binary_Translator.git
git clone git@github.com:KetchuppOfficial/My_Lib.git
cd Binary_Translator
```

**Step 3:** Build the project. 
```bash
username@machine:~/Some_Temp_Dir/Binary_Translator$ make
Collecting dependencies for "src/Binary_Translator.c"...
Collecting dependencies for "src/main.c"...
Compiling "src/main.c"...
Compiling "src/Binary_Translator.c"...
Linking project...
```
Some options are supported:

1) You can turn on all **MY_ASSERT** macros from **My_Lib** (kind of debug mode):
```bash
make OPT=-DDEBUG
```
2) Some basic compiler options such as optimization flag **-O2** can be used:
```bash
make OPT=-O2
```
3) Binary translator supports *stress test mode* (program is executed for 10 000 000 times):
```bash
make OPT=-DSTRESS_TEST
```
4) It's possible to use previous options simultaneously:
```bash
make OPT=-DDEBUG\ -DSTRESS_TEST\ -O2    # don't forget backslash!
```

**Step 4:** Running
```bash
make run IN=<input_file_name>
```
The program won't work if you don't specify <input_file_name>.

## Performance comparison

The performance of binary translator and processor emulator was tested on two programs implemented on my assembler language. Both programs have two versions: the first one - for the translator, the second one - for the emulator. The difference between them is that the emulator version uses **hlt** instructions to return from the program, while translator version uses **ret** for the same purpose.

The goal is to compare execution time and find out, how faster the binary translator is comparing to the processor emulator. I carried out the measurements by tool **time**. The execution time of the entire program was measured in both cases. The measurement error caused by translating bytecode into machine code by the translator is negligible comparing to the whole execution time. You can find proofs below.

### Quadratic equation

This test is to solve the good old quadratic equation. I've written a program that solves equation 124.1 * x^2 - 2345.8 * x + 294.4 = 0. You can find source code [here](/data/Quadratic_For_Tests.txt).

**My Processor**

| real, s | user, s |
|---------|---------|
| 75.225  | 75.119  |
| 74.361  | 74.281  |
| 74.174  | 74.104  |
| 75.047  | 74.954  |
| 74.494  | 74.410  |

|         | real, s | user, s |
|---------|---------|---------|
| average |  74.7   |  74.6   |
| std dev |   0.4   |   0.3   |

**Binary Translator**

One calculation:

| real, s | user, s |
|---------|---------|
|  0.002  |  0.002  |

10 000 000 calculations:

| real, s | user, s |
|---------|---------|
|  3.284  |  3.277  |
|  3.276  |  3.268  |
|  3.269  |  3.267  |
|  3.276  |  3.269  |
|  3.274  |  3.267  |

|         | real, s | user, s |
|---------|---------|---------|
| average |  3.276  |  3,270  |
| std dev |  0.003  |  0.002  |

We see that the binary translator is **22,8 +- 0.1** times faster than the processor emulator in terms of solving quadratic equations.

### Factorial

This test is to calculate factorial of some number.
I've written a program that calculates 10!. You can find source code [here](/data/Factorial_For_Tests.txt).

**My Processor:**

| real, s | user, s |
|---------|---------|
| 119.849 | 119.799 |
| 120.496 | 120.414 |
| 121.613 | 121.484 |
| 121.032 | 120.926 |
| 120.856 | 120.774 |

|         | real, s | user, s |
|---------|---------|---------|
| average |  120.8  |  120.7  |
| std dev |    0.5  |    0.5  |

**Binary Translator:**

One calculation:

| real, s | user, s |
|---------|---------|
|  0.002  |  0.002  |

10 000 000 calculations:

| real, s | user, s |
|---------|---------|
|  5.716  |  5.707  |
|  5.719  |  5.703  |
|  5.696  |  5.689  |
|  5.689  |  5.685  |
|  5.728  |  5.717  |

|         | real, s | user, s |
|---------|---------|---------|
| average |  5.71   |  5.70   |
| std dev |  0.01   |  0.01   |

Finally, binary translator is **21,2 +- 0,1** times faster than my processor emulator in calculating factorial.

## Future

First of all, it's reasonable to perform some optimizations on the machine code before execution. It will reduce the number of instructions and, consequently, the performance will increase.

The second and the last, this task can be continued it terms of generating an ELF file as a result of binary translation.
