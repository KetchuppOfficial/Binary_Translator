![Linux](https://img.shields.io/badge/Linux-FCC624?style=for-the-badge&logo=linux&logoColor=black)

# Binary Translator

This project is the final part of a course on programming and computer architecture by [Ilya Dedinsky (aka ded32)](https://github.com/ded32) that he teaches in MIPT.

## General Information

This program is a binary translator from bytecode generated by [my assembler](https://github.com/KetchuppOfficial/Processor) into x86-64 machine code. Executing of the machine code is implemented as a JIT-compiler. You can find information about my processor ISA and it's equivalents in x86-64 [here](/ISA.md).

## Dependencies

Before installing **Binary_Translator** make sure you have [My_Lib](https://github.com/KetchuppOfficial/My_Lib) installed on your PC. This library is an integral part of the project. Nothing will work without it.

## Build and run

**Binary_Translator** is released for Linux only.

Download this repository:
```bash
git clone git@github.com:KetchuppOfficial/Binary_Translator.git
cd Binary_Translator
```

Change the path to **My_Lib** to your own in Makefile.
```Makefile
CC     = gcc
CFLAGS = -Wall -Werror -Wshadow -Wfloat-equal -Wswitch-default

DEBUG = -g

MY_LIB_PATH  = /home/ketchupp/Programming/My_Lib/   # <------ Here
```

Then compile the program using tool **make**:
```bash
make
```

Congratulations! You can finally use **Binary_Translator**. To run the program, use **make** again:
```bash
make run IN=<input_file_name>
```
The program won't work if you don't specify <input_file_name>.

## Performance comparison

I implemented a program that solves a quadratic equation for 100000000 times. It was written on my own **assembler** language. Actually, there are two version of this program: the first one is for my **processor** (it contains **hlt** instructions), the second one is for **binary translator** (it contains **ret** instructions). You can find them [here](/data). Then, I used my **assembler** to make binary files of both versions. These programs were run on my **processor** and **binary translator**.

The goal was to compare execution time and find out, how faster **binary translator** is. I carried out the measurements by tool **time**. The execution time of the entire program was measured in both cases. The measurement error caused by translating bytecode into machine code by **binary translator** is negligible comparing to the whole execution time.

**My Processor (-O0)**


|    real   |    user   |    sys    |
|-----------|-----------|-----------|
| 1m11,658s | 1m11,192s | 0m0,436s  |

**Binary Translator (-O0)**

|   real   |    user   |    sys    |
|----------|-----------|-----------|
| 0m3,274s | 0m3,268s  | 0m0,004s  |

We see that **binary translator** is approximately 22 times faster than **processor**.

## Future

First of all, it's reasonable to perform some optimizations on machine code becore executing. It will reduce the number of instructions and, consequently, the performancy will increase.

Second and the last, this task can be continued it terms of generating an ELF file as a result of **binary translator** work.
